---
icon: pen-to-square
date: 2023-07-10
category:
  - 数字后端
tag:
  - 数字后端
---
# 1 综述

## 1.1 数字系统芯片设计

首先简述全流程：

系统设计 -> 功能验证 -> 逻辑综合 -> 物理实施



### 1.1.1 设计流程

首先给出设计的流程图

IP级设计 -> 系统级设计 -> 逻辑综合 -> 版图规划 -> 总线规划 -> FCT Budget -> Pin指定 -> 电源规划 -> 时钟规划



1. IP级设计

   购买/设计IP，得到RTL代码文件

2. 系统级设计

   把RTL代码划分为block，有些要把几个IP划分为一个block，有些把一个IP划分为多个block。划分为block后，它们仍然是以RTL代码的形式存在的。

3. 逻辑综合(logic synthesis)

   把每个block的RTL代码分别综合成一个个网表文件，此时它们的文件形式从RTL代码文件变成了Netlist文件。但是它们仍然以block划分。

4. 版图规划(Floor Plan)

   在版图上根据block之间关系的密切程度，规划block在版图上的位置、面积等，力求在面积、易于接线方面的合理性。即：既要达到面积最小，又要方便后续的接线。

5. 总线规划(Bus Plan)

   完成版图规划后，把总线的走向、走法规划好，每一个block都必须考虑到。

6. FCT Budget

7. Pin指定(Pin Assignment)

   对于每一个block，它们pin的位置、方向都是需要指定的，这一步要根据走线的结果来定。

8. 电源规划(Power Plan)

   把每一个block的功耗信息都做上标记。

9. 时钟规划(Clock Plan)

   规划时钟树。这一步分为不同的层级，包括block level和chip level。block level只能看到少数的几个层，chip level能看到的层数更多，通常是全部层。

   时钟规划需要充分考虑到各个模块的延时，从而确保时钟信号到达对称模块或者相互间有关系的模块时，时钟之间的不同步不至于让芯片失效。



以上所有项目都需要由专门的工程师负责，每位工程师/每个团队的职能都不同。



### 1.1.2 Block PnR流程

什么是PnR？

PnR是Place and Route的缩写（我猜的），是将综合后的block放置在版图上，并完成走线的过程，应该可以简称为布局布线。注意，布局和布线是两个过程，而不是一个。

1. 设计数据

   这个步骤主要是对一些文件进行辨别，这些文件具有不同的后缀名，或者具有不同的属性。

   - **Netlist**

   网表文件是RTL代码综合的结果，它保存了各个器件之间的互联信息。注意，这里是对各个block的RTL代码综合的结果，所以Netlist仍以block的形式存在。

   - **def**

   保存了block的形状和面积信息。

   - **lib**

   分为logic library和physical library

   logic library：保存了信号通过某一个门产生的延时。

   physical library：保存了门的大小和形状信息。

   - **delay**

   保存了信号通过一个逻辑块/网表内的电路造成的延时。这点和lib文件中的logic library是不一样的。

   - **tf**

   保存了晶圆厂(Foundry)给的设计物理规则，是设计时必须加载的文件。

   

2. 布图规划 Floor plan

   **检查def**

   如果有def，可以直接用def文件进行布图规划，因为里面已经保存了每个block的形状和面积。如果没有def，则需要初始化floor plan，自行创建def文件。

   **创建def**

   在没有def的情况下，需要手动创建def。首先需要初始化floor plan。

   1. 放置macro

      接着开始摆放macro，所谓的macro是相对于STD（标准器件）而言的，它主要是一些非标准的IP，需要手动摆放。一个设计中可能有很多macro，所以要把它们都摆放到floor plan里面。

   2. 电源规划

      除了VDD之外，还有VSS或者其他电压需要布线，要做好电源规划。另外，这些电源也要连接衬底/阱等需要保持某个电压的部分上。

   3. 导入physical cell

      logical cell是指带有逻辑功能的单元，它强调的是逻辑功能。而physical cell强调物理。

   然后，将这些macro固定在版图上。

3. 布局

   把STD标准器件摆放到摆放区域。

4. 时钟树综合(CTS)

   尽管这个时候的时钟树布线都是理想状态，每条线的延迟为0，但还是要尽量保证延时不出问题。从时钟树的树根(root)到每一个块的clk pin的延时latency无偏差或者尽可能小，即skew尽可能小。

5. 布线

   以晶圆厂所给的设计规则进行布线。

6. 简单的静态时序估算

7. RC提取

   抽取出RC delay，用于静态时序分析

8. 静态时序分析（STA）

   

9. 布线后优化

10. 物理设计验证

    物理验证包括两部分，LVS、DRC、PFM。

    **LVS**，用于确保<mark>版图和电路的一致性</mark>。

    **physical DRC**，主要是保证满足<mark>晶圆厂提供的</mark>物理要求，比如最小线宽要求、最小间距要求。

    **PFM**，<mark>良率</mark>检查。

11. 逻辑等价检查

    检查在以上步骤完成后，是否有逻辑上的偏差。理论上，经过这些设计后，它们的逻辑功能是<mark>不应该</mark>发生改变的。

12. 设计“签核”

    确认无误后，才可以核签。





## 1.2 物理设计

### 1.2.1 物理设计的主要问题

物理设计主要解决几个问题：

- 时序(Timing)

  是物理设计中的重要一步，主要还是保证时序不影响逻辑。

- DRC(Foundry)

  物理规则检查，由晶圆厂给的物理规则。

- 信号完整性(SI)

  随着线宽的不断缩小，信号完整性检查也变得越来越重要。在信号线平行经过的地方，如果一条线的频率过高，他就会对周围并行的线进行攻击，导致其他线的延时或者信号值发生改变，这种现象叫做cross talk，中文可以叫串扰。这是由信号线之间的寄生电容造成的。一般说来，信号完整性分析对时序正确也有很大影响。

  判断一个信号是否保持完整、未被串扰，需要做两点检查：

  1. 信号异常跳变的<mark>面积</mark>是否过大
  2. 信号跳变的<mark>高度</mark>是否过大

  以上两点都会对信号完整性由很大影响。

- 设计收敛

  必须保证每次PnR或者修改设计后，总体的效果是往好的方向（收敛）进行的，而不能越修改越差。关于这一点，需要更多地去实践。

- 时序收敛

  

- 功耗

  - 静态功耗

    - 静态泄露功耗

      从VDD到VSS之间的功耗。

  - 动态功耗

    - 翻转功耗

      翻转过程对电容、寄生电容充放电的功耗。

    - 导通功耗

      状态转换过程中，当触发器/反相器等模块中的CMOS处在在VDD的90%和10%的电压之中时，会有两管同时导通的情况，这个功耗取决于持续时间的长短，这个时间称为transition time。这个时间一般需要约束，而且需要分别考虑时钟信号CLK和数据信号DATA。

      注意，这个transition time并非做得越小越好。一般来说，如果希望transition time变小，需要付出其他代价，比如换用波形更好的buffer、在设计时增加buffer等，会增大buffer占用的面积等。有些追求是得不偿失的，所以只要满足设计所需的要求就可以，这里主要是要在面积和功耗之间灵活取舍。

- IR-drop，EM

  当电源经过了拥有大量触发器flip-flop的区域（通常是以“行”的形式存在的），而且这个区域的触发器同时翻转时，造成的瞬间大电流会让这片区域降落的电压远高于接下来其他触发器较少的区域，使后面的区域输入电压变小。这就是**IR-drop**。电压减小可能会导致后面区域的电压失效，进而导致整个芯片的功能失效。

  **EM**指的是<mark>电迁移</mark>，Electronic Migration。在电流不减小而线宽减小的情况下，电流密度会越变越大。于是电子流会不断冲击金属中的某些薄弱区域，导致断路，使芯片失效。

- DFM

  **DFM**指的是<mark>可制造性设计</mark>。

  例子：dummy metal

  当金属层中，金属线的分布不均匀，甚至不同区域在金属数量上差距悬殊时， 在制造时为了防止在化学腐蚀、机械抛光过程中带来的磨损程度不同的问题，需要在金属较少的区域插入一些dummy metal，使不同区域的金属密度一致。这些金属不具备任何电气功能，不与任何信号线路连接，他主要是为了让整片芯片在制造时磨损速率保持一致，提高良率。

  这只是其中一个例子，可制造性设计还有很多其他例子。一般来说，这一步在很多情况下只需要执行一条命令就可以了。

  

  ### 1.2.2 PR工具的解构

  <mark>content</mark>

  
